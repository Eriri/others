#include <bits/stdc++.h>
#define rep(i,s,t) for(int i=(s);i<(t);i++)
#define per(i,s,t) for(int i=((t)-1);i>=s;i--)
#define sz(x) ((int)x.size())
#define all(x) x.begin(),x.end()
#define pb push_back
#define mp make_pair
#define fi first
#define se second
using namespace std;

using uc=unsigned char;
using ui=unsigned int;
using u128 = unsigned __int128;
using block=vector<vector<uc>>;
using vb=vector<block>;
using keys=vector<vb>;

block zero={{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}};
block rcon={{0,0,0,0},{1,0,0,0},{2,0,0,0},{4,0,0,0},{8,0,0,0},{16,0,0,0},
			{32,0,0,0},{64,0,0,0},{128,0,0,0},{27,0,0,0},{54,0,0,0}};
block S_BOX[2] = {
	{{0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76},
	{0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0},
	{0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15},
	{0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75},
	{0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84},
	{0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF},
	{0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8},
	{0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2},
	{0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73},
	{0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB},
	{0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79},
	{0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08},
	{0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A},
	{0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E},
	{0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF},
	{0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16}},
	{{0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB},
	{0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB},
	{0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E},
	{0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25},
	{0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92},
	{0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84},
	{0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06},
	{0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B},
	{0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73},
	{0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E},
	{0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B},
	{0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4},
	{0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F},
	{0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF},
	{0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61},
	{0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D}}};

uc mul(ui a,ui b){
	ui c=0u,d=0x11b;
	while(b){c^=(b&1u)*a;b>>=1;a<<=1;}
	while(c>>8)c^=d<<(__builtin_clz(d)-__builtin_clz(c));
	return (uc)c;}

block excu(u128 x){block a=zero;rep(i,0,16)a[i>>2][i&3]=(uc)(x>>(i*8));return a;}
u128 excu(block x){u128 a=0;rep(i,0,16)a|=((u128)x[i>>2][i&3])<<(i*8);return a;}
block xor_block(block a,block b){rep(i,0,16)a[i>>2][i&3]^=b[i>>2][i&3];return a;}

block add_round_key(block a,block k){return xor_block(a,k);}

block sub_bytes(block a,int o){
	rep(i,0,4)rep(j,0,4)a[i][j]=S_BOX[o][a[i][j]>>4][a[i][j]&15];return a;}

block shift_rows(block a,int o){
	block b=zero;rep(i,0,4)rep(j,0,4)b[i][j]=a[i][o?(j+4-i)%4:(j+i)%4];return a;}
	
block mix_columns(block a,int o){
	block b=zero;uc c[2][4]={{2,3,1,1},{14,11,13,9}};
	rep(j,0,4)rep(i,0,4)rep(k,0,4)b[i][j]^=mul(a[k][j],c[o][(k+4-i)%4]);
	return b;}

vector<uc> rot_word(vector<uc> a){vector<uc> b;rep(i,0,4)b.pb(a[(i+1)%4]);return b;}
vector<uc> sub_word(vector<uc> a){rep(i,0,4)a[i]=S_BOX[0][a[i]>>4][a[i]&15];return a;}
vector<uc> xor_word(vector<uc> a,vector<uc> b){rep(i,0,4)a[i]^=b[i];return a;}

keys key_schedule(block a){
	int N=4,R=11;block W;vb t,s;
	rep(i,0,4*R){
		if(i<N)W.pb(a[i]);
		else if(i>=N&&i%N==0)W.pb(xor_word(W[i-N],xor_word(sub_word(rot_word(W[i-1])),rcon[i/N])));
		else if(i>=N&&N>6&&i%N==4)W.pb(xor_word(W[i-N],sub_word(W[i-1])));
		else W.pb(xor_word(W[i-N],W[i-1]));}
	rep(i,0,R)t.pb({W[4*i],W[4*i+1],W[4*i+2],W[4*i+3]});
	s=t;reverse(all(s));return {t,s};}

block enciphering(block a,keys k,int o){
	a=add_round_key(a,k[o][0]);
	rep(i,1,10){
		a=o?shift_rows(sub_bytes(a,o),o):sub_bytes(shift_rows(a,o),o);
		a=o?mix_columns(add_round_key(a,k[o][i]),o):add_round_key(mix_columns(a,o),k[o][i]);}
	a=o?sub_bytes(shift_rows(a,o),o):shift_rows(sub_bytes(a,o),o);
	return add_round_key(a,k[o][10]);}

u128 input_u128(){
	u128 x=0;string s;cin>>s;
	for(auto c:s){
		if('0'<=c&&c<='9')x=(x<<4)|(u128)(c-'0');
		if('a'<=c&&c<='f')x=(x<<4)|(u128)(c-'a'+10);
		if('A'<=c&&c<='F')x=(x<<4)|(u128)(c-'A'+10);}
	return x;}

u128 input_u128(string s){
	u128 x=0;
	for(auto c:s){
		if('0'<=c&&c<='9')x=(x<<4)|(u128)(c-'0');
		if('a'<=c&&c<='f')x=(x<<4)|(u128)(c-'a'+10);
		if('A'<=c&&c<='F')x=(x<<4)|(u128)(c-'A'+10);}
	return x;}
	
void output_u128(u128 x){
	string s;int y;
	rep(i,0,32){
		y=x&15;x>>=4;
		if(y<10)s+=(char)('0'+y);
		else s+=(char)('a'+y-10);}
	reverse(all(s));cout<<s;}

vb input_text(){
    string s;vb t;block x;
    while(sz(s)==0)getline(cin,s);s+=string(16-sz(s)%16,0);
    rep(i,0,sz(s)/16){
    	x=zero;rep(j,0,16)x[j>>2][j&3]=(uc)s[i+j];t.pb(x);}
	return t;}

vb input_data(){
	string s;stringstream ss;vb t;u128 x;block y;
	while(sz(s)==0)getline(cin,s);
	ss.clear();ss<<s;
	while(ss>>s){
		x=input_u128(s);y=zero;rep(j,0,16)y[j>>2][j&3]=(uc)(x>>(j*8));t.pb(y);}
	return t;}

void output_text(vb s){
	string t;
	rep(i,0,sz(s))rep(j,0,16)t+=(char)s[i][j>>2][j&3];
	cout<<t<<endl;}

void output_data(vb s){
	rep(i,0,sz(s)){output_u128(excu(s[i]));cout<<" ";}cout<<endl;}

int select_mode(vector<string> vs){
	int o;
	while(true){
		cout<<"请选择";rep(i,0,sz(vs))cout<<"["<<i<<"-"<<vs[i]<<"]";
		cout<<":";cin>>o;
		if(0<=o&&o<sz(vs)){
			cout<<"已选择:"<<vs[o]<<endl;
			return o;}}}

int main(){
	int o;random_device rd;u128 key,tiv;vb x;keys ks;block iv;
	while(true){
		o=select_mode({"加密","解密","退出"});
		if(o==0){
			cout<<"输入明文:";x=input_text();
			cout<<"明文为:";output_text(x);
			if(select_mode({"随机生成密钥","手动输入密钥"})==0){
				rep(i,0,128)key=key*2+rd();}
			else{cout<<"输入密钥(32位16进制数):";key=input_u128();}
			cout<<"密钥为(32位16进制数):";output_u128(key);cout<<endl;
			ks=key_schedule(excu(key));
			if(select_mode({"ECB","CBC"})==0)rep(i,0,sz(x))x[i]=enciphering(x[i],ks,0);
			else{
				if(select_mode({"随机生成初始化向量","手动输入初始化向量"})==0){
					rep(i,0,128)tiv=tiv*2+rd();iv=excu(tiv);}
				else{cout<<"输入初始化向量(32位16进制数):";iv=excu(input_u128());}
				cout<<"初始化向量(32位16进制数)为:";output_u128(excu(iv));cout<<endl;
				x[0]=enciphering(xor_block(x[0],iv),ks,0);
				rep(i,1,sz(x))x[i]=enciphering(xor_block(x[i],x[i-1]),ks,0);}
			cout<<"加密后密文为(分组32位16进制数):";output_data(x);}
		if(o==1){
			cout<<"输入分组密文(分组32位16进制数):";x=input_data();
			cout<<"分组密文(分组32位16进制数)为:";output_data(x);
			cout<<"输入密钥(32位16进制数):";key=input_u128();
			cout<<"密钥(32位16进制数)为:";output_u128(key);cout<<endl;
			if(select_mode({"ECB","CBC"})==0)rep(i,0,sz(x))x[i]=enciphering(x[i],ks,1);
			else{
				cout<<"输入初始化向量(32位16进制数):";iv=excu(input_u128());

				cout<<"初始化向量(32位16进制数)为:";output_u128(excu(iv));cout<<endl;
				per(i,1,sz(x))x[i]=xor_block(x[i-1],enciphering(x[i],ks,1));
				x[0]=xor_block(iv,enciphering(x[0],ks,1));}
			cout<<"解密后明文为:";output_text(x);}
		if(o==2)break;}}

